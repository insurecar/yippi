"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useDebouncedCallback;

var _hooks = require("preact/hooks");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function useDebouncedCallback(callback, delay, deps) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var maxWait = options.maxWait;
  var maxWaitHandler = (0, _hooks.useRef)(null);
  var maxWaitArgs = (0, _hooks.useRef)([]);
  var functionTimeoutHandler = (0, _hooks.useRef)(null);
  var isComponentUnmounted = (0, _hooks.useRef)(false);
  var debouncedFunction = (0, _hooks.useCallback)(callback, deps);
  var cancelDebouncedCallback = (0, _hooks.useCallback)(function () {
    clearTimeout(functionTimeoutHandler.current);
    clearTimeout(maxWaitHandler.current);
    maxWaitHandler.current = null;
    maxWaitArgs.current = [];
    functionTimeoutHandler.current = null;
  }, [functionTimeoutHandler.current, maxWaitHandler.current]);
  (0, _hooks.useEffect)(function () {
    return function () {
      // we use flag, as we allow to call callPending outside the hook
      isComponentUnmounted.current = true;
    };
  }, []);

  var debouncedCallback = function debouncedCallback() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    maxWaitArgs.current = args;
    clearTimeout(functionTimeoutHandler.current);
    functionTimeoutHandler.current = setTimeout(function () {
      if (!isComponentUnmounted.current) {
        debouncedFunction.apply(void 0, args);
      }

      cancelDebouncedCallback();
    }, delay);

    if (maxWait && !maxWaitHandler.current) {
      maxWaitHandler.current = setTimeout(function () {
        if (!isComponentUnmounted.current) {
          debouncedFunction.apply(void 0, _toConsumableArray(maxWaitArgs.current));
        }

        cancelDebouncedCallback();
      }, maxWait);
    }
  };

  var callPending = function callPending() {
    // Call pending callback only if we have anything in our queue
    if (!functionTimeoutHandler.current) {
      return;
    }

    debouncedFunction.apply(void 0, _toConsumableArray(maxWaitArgs.current));
    cancelDebouncedCallback();
  }; // For the moment, we use 3 args array so that we save backward compatibility


  return [debouncedCallback, cancelDebouncedCallback, callPending];
}